## Contents

- `main.tf` - a trivial Terraform configuration w/ an extra NSG rule that can be uncommented to observe a change in state
- `/plans` - Terraform plans + formatted JSON
  - Initial deployment (one NSG rule)
  - 2nd deployment (resources exist, add one new NSG rule)
- `/graphs` - Azure resource graphs captured after each deployment

## Usage

```shell
terraform init

terraform plan -o=./plans/0-initial.tfplan
terraform show -json ./plans/0-initial.tfplan | jq . > ./plans/0-initial.tfplan.json
terraform apply ./plans/0-initial.tfplan
az graph query -q 'where resourceGroup == "test-rg1"' > ./graphs/0-initial.graph.json

# uncomment the added NSG rule in main.tf

terraform plan -out=./plans/1-add-https.tfplan
terraform show -json ./plans/1-add-https.tfplan | jq . > ./plans/1-add-https.tfplan.json
terraform apply ./plans/1-add-https.tfplan
az graph query -q 'where resourceGroup == "test-rg1"' > ./graphs/1-add-https.graph.json

terraform destroy
```

For Powershell:
```shell
terraform init

terraform plan -out ./plans/0-initial.tfplan
terraform show -json ./plans/0-initial.tfplan | jq . > ./plans/0-initial.tfplan.json
terraform apply ./plans/0-initial.tfplan
az graph query -q "where resourceGroup == 'test-rg1'" > ./graphs/0-initial.graph.json

# uncomment the added NSG rule in main.tf

terraform plan -out ./plans/1-add-https.tfplan
terraform show -json ./plans/1-add-https.tfplan | jq . > ./plans/1-add-https.tfplan.json
terraform apply ./plans/1-add-https.tfplan
az graph query -q "where resourceGroup == 'test-rg1'" > ./graphs/1-add-https.graph.json

terraform destroy
```

## Learnings

- Terraform plan JSON files do not contain hydrated actual values on first plan, because those are populated at deployment time by the Azure resource provider. Ex:
  - "id" fields do not exist
  - Likewise for autogenerated properties like "defaultSecurityRules". An interpreter will need Azure domain knowledge of resource defaults to know (or reasonably guess) what the actual values will be if doing pre-deployment analysis
  - The actual IP address for a Dynamic publicIP is not allocated until a VM/Load Balancer is active
- Dereferencing links takes an extra step. Even with a trivial configuration, this requires at least some understanding/reimplementation of Terraform behavior. Untested pseudocode:

```js
const labyrinthItems = [];
foreach (const r in tfplan.planned_values.root_module.resources) {
  // Naive property conversion w/o dereferencing
  // These names don't match the ARM property names, so this step will need an adapter
  // Note: Terraform doesn't have a 1:1 resource mapping to the Azure REST API. Translation will be often trivial, but expect edge cases where Terraform is doing heavy lifting to make Azure easier to use
  const item = convert(r);

  // Associations are stored in a different element, linked by "address"
  const rConfig = tfplan.configuration.root_module.some(c => c.address === r.address);
  if (rConfig) {
    for (const prop of rConfig.expressions) {
      if (Array.isArray(prop)) {
        // handle arrays, matching by index & performing the steps for each element (below)
      } else {
        // if there is a "references" property, use the address specified here to point to another resource
        // note: "references" is an array. It's unclear when/if there are multiple elements
        if (prop.references) {
          // use "address" in place of "id" to link entities in the graph
          item[prop] = prop.resources[0];

          // alternately, dereference that object / look it up in a map to form a true object graph
          // const linkedResource = tfplan.planned_values.root_module.resources.some(v => v.address === prop.references[0]);
        }
      }
    }
  }
  labyrinthItems.push(item);
}
```

- Terraform makes it possible to quickly know what resources will be modified via `resource_changes`
  - Note: this gives first-order changes, and doesn't tell the full story of "Resource A was updated, but it's already linked to Resource B. This change actually breaks Resource B due to an added NSG rule (even though Resource B was untouched)", and so on. We'll have to do a reverse lookup through `configuration.root_module.resources.*` for `references` to build and analyze the full graph
- There are likely other issues yet to be uncovered, as this was a quick tour using a trivial infrastructure and did not invoke any HCL language features beyond simple references (conditionals, loops, etc)
